<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merge Sort - Explanation and Implementation</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        background-color: #f4f4f4;
        color: #333;
        margin: 0;
        padding: 20px;
      }

      h1,
      h2 {
        color: #2c3e50;
      }

      h3 {
        color: #2980b9;
      }

      pre {
        background-color: #f2f2f2;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        font-size: 1rem;
      }

      code {
        background-color: #eaeaea;
        padding: 2px 5px;
        border-radius: 3px;
      }

      .content {
        max-width: 1000px;
        margin: 0 auto;
      }

      .section {
        margin-bottom: 30px;
      }

      .code-block {
        margin: 20px 0;
        font-family: "Courier New", monospace;
        background-color: #e9ecef;
        padding: 15px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="content">
      <h1>Merge Sort</h1>

      <div class="section">
        <h2>What is Merge Sort?</h2>
        <p>
          <strong>Merge Sort</strong> is a divide-and-conquer sorting algorithm.
          It divides the input array into two halves, recursively sorts them,
          and then merges the two sorted halves into one sorted array.
        </p>
      </div>

      <div class="section">
        <h2>How It Works</h2>
        <ol>
          <li>
            <strong>Divide:</strong> Split the array into two halves until each
            subarray contains only one element (base case).
          </li>
          <li><strong>Conquer:</strong> Recursively sort the subarrays.</li>
          <li>
            <strong>Combine:</strong> Merge the sorted subarrays into a single
            sorted array.
          </li>
        </ol>
      </div>

      <div class="section">
        <h2>Key Characteristics</h2>
        <ul>
          <li>
            <strong>Stable Sorting:</strong> Maintains the relative order of
            equal elements.
          </li>
          <li>
            <strong>Divide-and-Conquer:</strong> Efficiently handles large
            datasets.
          </li>
          <li>
            <strong>Recursive Nature:</strong> Relies heavily on recursion to
            split and merge.
          </li>
        </ul>
      </div>

      <div class="section">
        <h2>Time Complexity</h2>
        <ul>
          <li>
            <strong>Best Case:</strong> <code>O(n log n)</code> (array is
            already sorted, but splitting and merging are still needed).
          </li>
          <li>
            <strong>Worst Case:</strong> <code>O(n log n)</code> (array is
            sorted in reverse order).
          </li>
          <li><strong>Average Case:</strong> <code>O(n log n)</code>.</li>
        </ul>
      </div>

      <div class="section">
        <h2>Space Complexity</h2>
        <p>
          <strong>Space:</strong> <code>O(n)</code> (requires additional space
          for merging).
        </p>
      </div>

      <div class="section">
        <h2>JavaScript Implementation</h2>

        <div class="code-block">
          <h3>Merge Function</h3>
          <p>
            The merge function takes two sorted arrays and combines them into
            one sorted array.
          </p>
          <pre><code>
const merge = (left, right) => {
  let sorted = [];
  let i = 0, j = 0;

  // Compare elements from left and right
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      sorted.push(left[i]);
      i++;
    } else {
      sorted.push(right[j]);
      j++;
    }
  }

  // Add any remaining elements
  return sorted.concat(left.slice(i)).concat(right.slice(j));
};
                </code></pre>
        </div>

        <div class="code-block">
          <h3>Merge Sort Algorithm</h3>
          <p>
            The main merge sort function recursively divides and merges the
            array.
          </p>
          <pre><code>
const mergeSort = (arr) => {
  // Base case: arrays with fewer than 2 elements are already sorted
  if (arr.length <= 1) return arr;

  // Split array into two halves
  let mid = Math.floor(arr.length / 2);
  let leftSlice = arr.slice(0, mid);
  let rightSlice = arr.slice(mid);

  // Recursively sort and merge the two halves
  return merge(mergeSort(leftSlice), mergeSort(rightSlice));
};

console.log(mergeSort([4, 6, 1, 3, 8, 5, 2, 89, 55, 67]));
                </code></pre>
        </div>
      </div>

      <div class="section">
        <h2>Example Output</h2>
        <p>
          For the input array: <code>[4, 6, 1, 3, 8, 5, 2, 89, 55, 67]</code>,
          the output after sorting will be:
        </p>
        <pre><code>[1, 2, 3, 4, 5, 6, 8, 55, 67, 89]</code></pre>
      </div>

      <div class="section">
        <h2>When is Merge Sort Useful?</h2>
        <ul>
          <li>
            <strong>Large Datasets:</strong> Performs well on large datasets due
            to its <code>O(n log n)</code> complexity.
          </li>
          <li>
            <strong>External Sorting:</strong> Suitable for situations where the
            dataset doesn't fit into memory (e.g., sorting data on disk).
          </li>
          <li>
            <strong>Stable Sorting:</strong> Useful when stability (preserving
            the relative order of equal elements) is important.
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
